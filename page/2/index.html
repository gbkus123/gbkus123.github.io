<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="中二病也要写代码">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="中二病也要写代码">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中二病也要写代码">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 中二病也要写代码 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?43fcc61fac5355f89b96342f4f1972c1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">中二病也要写代码</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/26/类和对象-属性/" itemprop="url">
                  类和对象-属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-26T16:11:53+08:00" content="2016-03-26">
              2016-03-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/26/类和对象-属性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/26/类和对象-属性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>属性的声明 </p>
</blockquote>
<p>以前用 <code>var $a=1;</code>,我从没用过,可以用 public,private ,protected 跟一个普通的变量声明,但这个普通的变量声明,声明属相如果单独写一个变量声明是语法错误<br>static 和 var 一样在不用访问控制关键字的时候,默认是 Public:</p>
<pre><code>    &lt;?php
class test{
    // $b=33;//此行语法错误 
    static $a=1;
}
class child extends test{
    function a(){
        echo self::$a;
    }
}
echo test::$a;//1
(new child())-&gt;a();//1
</code></pre><p>声明属性时可以初始化,就是赋给他一个值,但不能是变量,也不能是一个函数的返回值;</p>
<pre><code>&lt;?php
class test{
    public $int=1;
    public $str=&apos;abc&apos;;
    //public $res=array_merge([1],[2])//此行报语法错误
    // public $int=$str;//fatal error 语法错误
    // public $str=$this-&gt;int;//fatal error 语法犯错误
    // public $met=self::method();//语法错误,属性不可以是一个对象的引用
    public $obj=null;
    public $arr=[];
    public $eot=&lt;&lt;&lt;ABC
        abc
ABC;
    public $bool=true;
    static public function method(){

    }
}
</code></pre><blockquote>
<p>访问类的属性</p>
</blockquote>
<pre><code>&lt;?php
//访问类的经他属性和常量 不需要实例化就可访问只需要 className::
//访问类的非静态属性和方法 用 -&gt;
class test{
    const C=&apos;const&apos;.&quot;&lt;/br&gt;&quot;;
    public $a=&apos;a&apos;.&quot;&lt;/br&gt;&quot;;
    static public $b=&apos;b&apos;.&quot;&lt;/br&gt;&quot;;
    public function getAttri(){
        //在类中调用类的参数和属性
        echo self::C;//const
        echo $this-&gt;a;//a
        echo $this-&gt;b;//notice 和 e_strict,不可以用伪变量来调用静态属性
        // echo self::$a;//fatal error不是一个静态属性
        echo self::$b;//b
    }
    static function getAttris(){
        echo self::C;//const
        // echo $this-&gt;a;//fatal error 在静态方法中不可以使用 $this
        // echo $this-&gt;b;//fatal error 在静态方法中不可以使用 $this
        // echo self::$a;//fatal error不是一个静态属性
        echo self::$b;//b
    }
    }
    $t=new test();
    echo $t-&gt;C;//notice
    echo $t-&gt;b;//报 e_strict和 notice
    echo $t-&gt;a;//a
    echo test::$b;//b
    echo test::C;//const
    echo test::$b;//b
    $t-&gt;getAttri();
    test :: getAttris();
</code></pre><blockquote>
<p>Newdoc 和 Heredoc</p>
</blockquote>
<pre><code>    &lt;?php
    //php5以后 newdoc heredoc 都可以在属性声明中使用
    class test{
        public $eot=&lt;&lt;&lt;ABC
            abc
ABC;
        static public $here=&lt;&lt;&lt;HERE
        heredoc
HERE;
            public $new=&lt;&lt;&lt;&apos;ABC&apos;
            new
ABC;
        static public $news=&lt;&lt;&lt;&apos;HERE&apos;
        news
HERE;

    }
    echo (new test())-&gt;eot;//abc
    echo test:: $here;//heredoc
    echo (new test())-&gt;new;//new 
    echo test::$news;//news
</code></pre><blockquote>
<p>伪变量$this调用属性时的技巧</p>
</blockquote>
<pre><code>&lt;?php
class Test{
public     $a=&apos;a&apos;;
    function geta(){
        echo $this-&gt;$a;
        //这里会报 notice 因为没有&apos;$a&apos;这个属性,
        //然后报 fatalerror不能获取一个空的数据
    }
    function getas(){
        $a=&apos;a&apos;;
        echo $this-&gt;$a;
        //这里输出 a php 把$a 解析为 a 所以就找到了 属性 public $a
    }
}
$t=new Test();
$t-&gt;getas();
$t-&gt;geta();
</code></pre><blockquote>
<p>demo</p>
</blockquote>
<pre><code>&lt;?php 

class test 
{ 
    public $var1 = 1; 
    protected $var2 = 2; 
    private $var3 = 3; 
    static $var4 = 4; 

    public function toArray() 
    { 
        return (array) $this; 
    } 
    public function getval(){
        return get_object_vars($this);
    }

} 

$t = new test; 
print_r(get_class_vars(&apos;test&apos;));
print_r($t-&gt;getval());
print_r(get_object_vars($t));
print_r($t-&gt;toArray()); 

/* outputs: 
Array (
 [var1] =&gt; 1 
 [var4] =&gt; 4 
 ) 
 Array ( 
 [var1] =&gt; 1 
 [var2] =&gt; 2 
 [var3] =&gt; 3 
 ) 
  Array ( 
  [var1] =&gt; 1 
  )
Array 
( 
    [var1] =&gt; 1 
    [ * var2] =&gt; 2 
    [ test var3] =&gt; 3 
) 

*/ 
?&gt; 
</code></pre><p>&gt;</p>
<pre><code>&lt;?php

abstract class PropertyObject
{
  public function __get($name)
  {
    if (method_exists($this, ($method = &apos;get_&apos;.$name)))
    {
      return $this-&gt;$method();
    }
    else return;
  }

  public function __isset($name)
  {
    if (method_exists($this, ($method = &apos;isset_&apos;.$name)))
    {
      return $this-&gt;$method();
    }
    else return;
  }

  public function __set($name, $value)
  {
    if (method_exists($this, ($method = &apos;set_&apos;.$name)))
    {
      $this-&gt;$method($value);
    }
  }

  public function __unset($name)
  {
    if (method_exists($this, ($method = &apos;unset_&apos;.$name)))
    {
      $this-&gt;$method();
    }
  }
}

?&gt;
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/类和对象 /" itemprop="url">
                  类和对象-基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-23T13:22:15+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/23/类和对象 /#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/23/类和对象 /" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>声明和访问一个对象</p>
</blockquote>
<pre><code>&lt;?php
//声明
$a=(object)[1,2,3];
var_dump($a);
  // object(stdClass)[1]
 //      public 0 =&gt; int 1
 //      public 1 =&gt; int 2
 //      public 2 =&gt; int 3
// 两种访问方式
class a{
    public $a=1;
}
$a=new a();
echo $a-&gt;a;//1
echo (new a())-&gt;a;//1
</code></pre><blockquote>
<p>声明一个类</p>
</blockquote>
<pre><code>&lt;?php
class Test{
    //为了符合psr-0类的首字母要大写
    public $a=1;
    public function getA(){
    return $this-&gt;a;//类中内部调用可以使用伪变量，$this,既是对该类的引用
    }
}
echo  (new Test())-&gt;getA();//输出 1 
</code></pre><blockquote>
<p>伪变量$this</p>
</blockquote>
<pre><code>    &lt;?php
class abc{
    function foo(){
        if(isset($this)){
            echo  &apos;$this object name:&apos;.get_class($this).&quot;&lt;/br&gt;&quot;;
        }
        else{
        echo  &apos;$this is not defined&apos;.&quot;&lt;/br&gt;&quot;;
    }
    }
}
class efg{
    function bar(){
        abc::foo();
    }
}
(new abc())-&gt;foo();//$this object name: abc
 abc::foo();//$this is not defined 并且报错 不是静态方法不能用::,
 //静态类不允许使用$this这个为伪变量所以静态调用一个非静态方法也会这样
 (new efg())-&gt;bar();//$this object name : eft  并且报错 不是静态方法不能用::
 // 与上面不同从第二个类里面静态调用时返回的发起调用的那个方法也就是bar(),此时返回的是类efg
 efg::bar();//$this is not defined  并且报错 不是静态方法不能用::与上面的上面那个同理
</code></pre><blockquote>
<p>new 关键字</p>
</blockquote>
<pre><code>&lt;?php

class Defined{
    public $a=1;
    function abc(){
        echo &apos;abc&apos;;
    }
}
// $undefined=new undefined();//fatal error,因为没有找个这个类
echo (new Defined())-&gt;a;//1
$className=&apos;Defined&apos;;
echo  (new $className())-&gt;abc();
//abc，可以用和类名相同的字符串来创建一个对象
$obj=new Defined();
echo $obj-&gt;a;//1
</code></pre><blockquote>
<p>类的引用和赋值</p>
</blockquote>
<pre><code>&lt;?php
class obj{
    public $a = 0;
}
$old = new obj();
$givedOld = $old;
$pointOld = &amp;$old;
echo ($old===$givedOld);//1,true
echo ($pointOld===$old);//1,true
$old-&gt;a=1;//此时 old giveold pointold 的$a都等于1
//因为虽然 (old与 pointold)  和 giveold 存储位置不同,但是属性都属于一个对象(类)
$old=null;//Old 和 pointold存储位置相同所以都被覆盖为Null,但giveold和他们的存储位置
//是不同的不会被覆盖,并且依然保留从之前对象复制的属性
var_dump($old);//null
var_dump($givedOld);//object{public a =&gt; 1}
var_dump($pointOld);//null
//对象引用和赋值和其他标量类型差不多，赋值是创建了一个新对象
</code></pre><blockquote>
<p>new self;</p>
</blockquote>
<pre><code>&lt;?php
//new self,当self前面加上new的时候，返回(引用)的是:
//和new self这行代码所在的类,相同的类
class A{
    function  getSelf(){
        return new self;
    }
    static function getSelfs(){
        return new self;
    }
}
class B extends A{

}
$a=new A();
$b=new B();
echo get_class($a-&gt;getSelf()).&quot;&lt;/br&gt;&quot;;//A
echo get_class($b-&gt;getSelf()).&quot;&lt;/br&gt;&quot;;//A
echo get_class(A::getSelfs()).&quot;&lt;/br&gt;&quot;;//A
echo get_class(B::getSelfs()).&quot;&lt;/br&gt;&quot;;//A
</code></pre><blockquote>
<p>new parent ;</p>
</blockquote>
<pre><code>&lt;?php
//new parent,返回:
//和new parent这行代码所在的父类,相同的类
class A{

}
class B extends A{
function  getParent(){
        return new parent;
    }
    static function getParents(){
        return new parent;
    }
}
class C extends B{

}
$a=new A();
$b=new B();
$c=new C();
echo get_class($b-&gt;getParent()).&quot;&lt;/br&gt;&quot;;//A
echo get_class(B::getParents()).&quot;&lt;/br&gt;&quot;;//A
echo get_class($c-&gt;getParent()).&quot;&lt;/br&gt;&quot;;//A
echo get_class(C::getParents()).&quot;&lt;/br&gt;&quot;;//A
</code></pre><blockquote>
<p>new static;</p>
</blockquote>
<pre><code>&lt;?php
//new static,返回:
//引用,调用方法时所在的类
class A{
    function  getStatic(){
        return new static;
    }
    static function getStatics(){
        return new static;
    }
}
class B extends A{

}
$a=new A();
$b=new B();
echo get_class($a-&gt;getStatic()).&quot;&lt;/br&gt;&quot;;//A
echo get_class(A::getStatics()).&quot;&lt;/br&gt;&quot;;//A
echo get_class($b-&gt;getStatic()).&quot;&lt;/br&gt;&quot;;//B
echo get_class(B::getStatics()).&quot;&lt;/br&gt;&quot;;//B
</code></pre><blockquote>
<p>创建新对象的林外一种方式 ,new $obj(一个对象变量)</p>
</blockquote>
<pre><code>    &lt;?php
class A{
    function  getSelf(){
        return new self;
    }
    static function getStatic(){
        return new static;
    }
}
class B extends A{
    function getParent(){
        return new parent;
    }
}
$a=new A();
$b=new B();
$A=new $a;
$B=new $b;
var_dump ($a===$A);//false
var_dump ($b===$B);//false
echo get_class($A-&gt;getSelf()).&quot;&lt;/br&gt;&quot;;//A
var_dump ($A instanceof A).&quot;&lt;/br&gt;&quot;;//true
echo get_class($B-&gt;getParent()).&quot;&lt;/br&gt;&quot;;//A
var_dump ($B-&gt;getParent() instanceof B).&quot;&lt;/br&gt;&quot;;//false
var_dump ($B-&gt;getParent() instanceof A).&quot;&lt;/br&gt;&quot;;//true
</code></pre><blockquote>
<p>final 关键字 与 继承</p>
</blockquote>
<p>php继承为单继承,只能继承一个父类</p>
<pre><code>&lt;?php
//方法被声明为 final 的话子类不能被声明,而声明为 Final 的类不能被继承
class Finfunc{
    final public function test(){
        echo &quot;the Final function &quot;;
    }
    public function arguments($one){

    }
    public function __construct($one){

    }
}
// class child extends Finfunc{

//     public function test(){
//         echo &quot;this&apos;s will report a fatal error&quot;;
//         //这里会报错:Fatal error: Cannot override final method Finfunc::test() i
//     }
// final class FinClass{}
// class childs extends FinClass{
//     //这里会报错: Fatal error: Class childs may not inherit from final class 
// }    
class children extends Finfunc{
    function a(){
    $this-&gt;test();//输出the Final function
    parent::test();    //输出the Final function
}
    public function arguments($one,$two){
        echo $one;//输出1
        echo $two;//输出2
        //此处会抱一个 e_strict的错误,重载函数时参数要一致

    }
    public function __construct($three=0,$four=0){
        //构造函数被覆盖时如果参数不一致不会报错误
        echo $three;//输出3
        echo $four;//输出4
    }
}

(new children(3,4))-&gt;arguments(1,2);

(new children)-&gt;a();
</code></pre><blockquote>
<p>::class</p>
</blockquote>
<pre><code>&lt;?php
class name{

}
echo name::class;//输出 name
</code></pre><p>自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。这对使用了 命名空间 的类尤其有用。</p>
<pre><code>&lt;?php
namespace NS {
class ClassName {
}

    echo ClassName::class;//输出　NS\ClassName
}
?&gt;
</code></pre><blockquote>
<p>demo</p>
</blockquote>
<pre><code>&lt;?php

class a {

    public static $foo = &apos;I am foo&apos;.&quot;&lt;/br&gt;&quot;;
    public $bar = &apos;I am bar&apos;.&quot;&lt;/br&gt;&quot;;

    public static function getFoo() { echo self::$foo;    }
    public static function setFoo() { self::$foo = &apos;I am a new foo&apos;; }
    public function getBar() { echo $this-&gt;bar;    }            
}

$ob = new a();
a::getFoo();     // output: I am foo    
$ob-&gt;getFoo();    // output: I am foo
// a::getBar();     // fatal error: using $this not in object context
$ob-&gt;getBar();    // output: I am bar
                // If you keep $bar non static this will work
                // but if bar was static, then var_dump($this-&gt;bar) will output null 

// unset($ob);
a::setFoo();    // The same effect as if you called $ob-&gt;setFoo(); because $foo is static
$c = new a();     // This will have no effects on $foo
$-&gt;getFoo();    // output: I am a new foo 
</code></pre><p>&gt;</p>
<pre><code>&lt;?php
//两种方式创建一个空对象,但一般用不到
$way1=new stdClass;
//stdClass 是一个php 内置类,再将一些标量转化为对象时
//会默认创建了一个 stdclass 的事例
echo get_class((object)[1,23]).&quot;&lt;/br&gt;&quot;;//stdClass
$way1-&gt;a=&apos;a&apos;;
echo $way1-&gt;a.&quot;&lt;/br&gt;&quot;;//输出a

$way2=json_decode(&apos;{}&apos;);
$way2-&gt;b=&apos;b&apos;;
echo $way2-&gt;b;//输出 b
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/php数组/" itemprop="url">
                  php数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T16:27:24+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/18/php数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/18/php数组/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>###1.php数组和其他语言数组的区别</p>
</blockquote>
<p>#####先来一段官网的：</p>
<p><strong>PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，<br>或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维<br>数组也是允许的。</strong></p>
<hr>
<p>我认为的拍黄片的数组和强类型语言的数组之间的区别，就像弱类型语言和强类型语言的区别是一样的，别的语言数组，链表，集合，字典什么的都是分开的，就像强类型语言需要声明类型，而Php不需要，所以php得数组也是这样，他是所有数据结构的集合体，Php用数组来描述数据结构，这一点很高级但又使用简单，容易理解却很难真正理解</p>
<hr>
<blockquote>
<p>###2.数组语法</p>
</blockquote>
<p>简单语法，声明数组：</p>
<pre><code>&lt;?php
//5.4之前用array()
$a=array(
    1=&gt;2,
    2=&gt;3);//最后一个键值对后面可以不写&apos;,&apos;
//5.4之后用[]
$b=[1=&gt;2,2=&gt;3];
//key可以是integer 或者string ,value的话可以使任意类型
</code></pre><p>key类型的必须是interger 或者string ，这就意味着Key会发生强制转换,而且相同的key则相同的Key会别最后一个覆盖：</p>
<pre><code>&lt;?php
$a=[08=&gt;1];
var_dump($a);//  0 =&gt; int 1， 08不是一个合法十进制被转为0

$a=[&apos;08&apos;=&gt;1];
var_dump($a);//&apos;08&apos; =&gt; int 1 ，08不是合法十进制整数则不会强转

$a=[&apos;134&apos;=&gt;1];
var_dump($a);//  134 =&gt; int 1,key包含合法整数被强转为int

$a=[&apos;134e3&apos;=&gt;1];
var_dump($a);//// &apos;134e3&apos; =&gt; int 1,key不是一个合法的整数值，(和进制无关123aab也是如此）

$a=[1.11=&gt;1,2.9=&gt;2];
var_dump($a);//  1 =&gt; int 1 ,2 =&gt; int 2 浮点数会被直接去掉小数部分

$a=[&apos;1.11&apos;=&gt;1.1,&apos;2.9&apos;=&gt;2.2];
var_dump($a);//  &apos;1.11&apos; =&gt; float 1.1 ,&apos;2.2&apos; =&gt; float 2.2 字符串中的浮点数不是一个合法的整数不会被强转

$a=[true=&gt;1,false=&gt;0];
var_dump($a);//  1 =&gt; int 1 ,0 =&gt; int 0 true转为1 false转为0

$a=[&apos;&apos;=&gt;1,NULL=&gt;2];
var_dump($a);//第二个null被转为&apos;&apos;,覆盖前面的以空字符串的Key
echo $a[&apos;&apos;];//输出2,这种东西知道就好了，开发中要是这么写，分分钟让你去日最野的狗

$a=[$a=&gt;1];
var_dump($a);//报错llegal offset type，并且数组为空了，数组不可做key

class a{}
$b=new a();
$a=[$b=&gt;1];
var_dump($a);//报错llegal offset type，并且数组为空了，对象不可做key
</code></pre><blockquote>
<p>其实上面的内容一个数组就理解了</p>
</blockquote>
<pre><code>&lt;?php
$a=[
1=&gt;&apos;int1&apos;,
1.1=&gt;&apos;float1.1&apos;,
&apos;1.1&apos;=&gt;&apos;str1.1&apos;,
&apos;1&apos;=&gt;&apos;str1&apos;,
true=&gt;&apos;true&apos;,
];
var_dump($a);//1 =&gt; string &apos;true&apos; (length=4),&apos;1.1&apos; =&gt; string &apos;str1.1&apos; (length=6)
</code></pre><p>如果string和int混合类型的时候，如果有一个未指定Key的value，那么会给他分配之前最大的Key+1的value</p>
<pre><code>&lt;?php
$a=[
    &apos;str&apos;=&gt;&apos;str&apos;,0
];
var_dump($a);// &apos;str&apos; =&gt; string &apos;str&apos; (length=3), 0 =&gt; int 0
$b=[&apos;123&apos;=&gt;123,124];
var_dump($b);//  123 =&gt; int 123,124 =&gt; int 124
$c=[124=&gt;124,111=&gt;111,&apos;x&apos;,125=&gt;125];
  var_dump($c);//  124 =&gt; int 124,111 =&gt; int 111,125 =&gt; int 125,这里的话x没了因为x的未定义key他被分配
  //key是之前最大的Key+1=124+1=125,而125得key有后面相同，被覆盖了。。。
</code></pre><p> 如果是都没指定key的话，是从0开始的，如果中间有插入的话，就不一样了:</p>
<pre><code>&lt;?php
$a=[
    0,1,2,3,3=&gt;4,5,6,11=&gt;7,8
    ];
    var_dump($a);
      // 0 =&gt; int 0
      // 1 =&gt; int 1
      // 2 =&gt; int 2
      // 3 =&gt; int 4
      // 4 =&gt; int 5
      // 5 =&gt; int 6
      // 11 =&gt; int 7
      // 12 =&gt; int 8
</code></pre><p>访问数组时可以用[],也可以用{}，反正都是同一对按键</p>
<pre><code>&lt;?php
function getArray(){
    return [1,2,3];
}
echo getArray()[0];//1
$arr=getArray();
echo $arr[1];//2
list($one)=$arr;
echo $one;//1
list(,$two)=$arr;
echo $two;//2
list(,,$three)=$arr;
echo $three;//3
list(,,,$four)=$arr;
var_dump($four) ;//null,并且报notice 找不到key=3的数组元素，试图访问一个未定义的数组key，就会这样
</code></pre><p>数组增加删除修改</p>
<pre><code>&lt;?php
$arr=[1,2,3];
$arr[]=4;
var_dump($arr);//这种写法相当于array_push 就是追加一个元素,可以在[]中指定Key,也可以不指定
// 0 =&gt; int 1
  // 1 =&gt; int 2
// 2 =&gt; int 3
  // 3 =&gt; int 4
$arr=[4];
var_dump($arr);//这种写法相当于覆盖了之前的变量
 // 0 =&gt; int 4
$arr[&apos;4&apos;]=4;
var_dump($arr);
  // 0 =&gt; int 4
  // 4 =&gt; int 4
unset($arr[4]);//追加了&apos;4&apos;这个Key,被强转为int所以可以被unset掉
var_dump($arr);
  // 0 =&gt; int 4
</code></pre><p>关于数组索引的问题：</p>
<pre><code>    &lt;?php
function ua(&amp;$arr){
    foreach($arr as $k=&gt;$val){
    unset($arr[$k]);
    }
}
$arr=[0,1,2,3,4,5];
ua($arr);//Unset掉数组的所有元素，unset不会重建索引
$arr[]=0;
var_dump($arr);//6=&gt;0 该数组在上次索引时最大key是5，所以新元素的Key是6
$arr=[0,1,2,3,4,5];
var_dump($arr);//上面这么写是给变量一个新的数组，key是另外一个数组重新索引的
 //  0 =&gt; int 0
 // 1 =&gt; int 1
  // 2 =&gt; int 2
  // 3 =&gt; int 3
  // 4 =&gt; int 4
  // 5 =&gt; int 5
ua($arr);//再次unset掉所有元素
$arr=array_values($arr);//array_values是以重新索引的方式返回数组所有的value，也相当与一个新数组
$arr[]=0;
var_dump($arr);
//0=&gt;int 0 这个就是说新数组第一个元素，Key为0
</code></pre><p>访问数组时可以用函数返回值来作为key：</p>
<pre><code>&lt;?php
function getkey(){
    return rand(0,10);
}
$arr=[&apos;zero&apos;,&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;,&apos;five&apos;,&apos;six&apos;,&apos;seven&apos;,&apos;eight&apos;,&apos;night&apos;,&apos;ten&apos;];
echo $arr[getkey()];
</code></pre><p>转换为数组<br>    &lt;?php</p>
<pre><code>class obj{
    public $intpub=123;
    public $pub=&apos;public&apos;;
    protected $pro=&apos;protected&apos;;
    private $pri=&apos;private&apos;;
    const con=&apos;const&apos;;
    public function thefunc(){
            return &apos;func&apos;;
    }

}
$int=1234;
$float=1.234;
$string=&apos;abcdefg&apos;;
$true=true;
$false=false;
$resouce=dir(getcwd())-&gt;handle;
$null=null;
$obj=new obj();
var_dump((array)$int);//  0 =&gt; int 1234
var_dump((array)$float);// 0 =&gt; float 1.234
var_dump((array)$string);//  0 =&gt; string &apos;abcdefg&apos;
var_dump((array)$true);// 0 =&gt; boolean true
var_dump((array)$false);//  0 =&gt; boolean false
var_dump((array)$resouce);//  0 =&gt; resource(3, stream)
var_dump((array)$null);//  empty
print_r((array)$obj);//Array([intpub] =&gt; 123 [pub] =&gt; public [*pro] =&gt; protected [objpri] =&gt; private )
//int,float,string,boolean,resouce,转为数组会得到一个key=0,value=原值，Obj转数组，public:属性名=&gt;属性值，protected：*属性名=&gt;属性值，private:类名+属性名=&gt;属性值
</code></pre><p>数组运算符</p>
<pre><code>&lt;?php
//数组相加
$x=[0,1,2];
$y=[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];
var_dump($x+$y);//结果是保留$x的全部key value，因为$x和$y的Key相同，在+时，相同的Key+右边的数组被忽略
var_dump($y+$x);//结果是保留了$y的全部key value 
//数组比较
$a=[1,2,3];
$b=[2,1,3];
var_dump($a==$b);//false
$b=[1=&gt;2,0=&gt;1,3];
var_dump($a==$b);//true，==比较时同时比较key 和 value是否相等，但和在数组中的顺序无关
var_dump($a===$b);//false ,====比较时the two array&apos;s key and value must be same and  the order must be same
var_dump($a!=$b);//false !=时和==的条件是相同的
var_dump($a&lt;&gt;$b);//false &lt;&gt; 和 ==是一样的
var_dump($a!==$b);//true !== 和 ===的条件是相同的
</code></pre><p>数组的value 可以用用引用的方式来改变</p>
<pre><code>&lt;?php
$abc=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
foreach($abc as &amp;$val){
    $val=strtoupper($val);
}
var_dump($abc);//0=&gt;A ,1=&gt;B,2=&gt;C
//这里$val被引用传递所以和正常的foreach之后销毁变量不同，$val会保留数组最后一个value
var_dump($val);//C
</code></pre><p>数组复制中的值引用 </p>
<pre><code>&lt;?php
$a=[1,2,4];
$b=&amp;$a;
$b[]=4;
var_dump($a);//这里a=[1,2,3,4]
//php的引用和c的指针不同，但是可以用指针的概念去理解
</code></pre><p>demo</p>
<pre><code>&lt;?php
var_dump($_POST);
?&gt;
&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; ?&gt;&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;one.one&quot; value=&quot;1.1&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;post&quot; &gt;
&lt;/form&gt;
//很奇怪 one.one 会变成 one_one=&gt;1.1
</code></pre><p>&gt;</p>
<pre><code>&lt;?php
//序列化后对值没影响，说明引用是安全的
$x=&apos;old&apos;;
$a=[&apos;a&apos;=&gt;&amp;$x,&apos;b&apos;=&gt;&amp;$x];
$a=unserialize(serialize($a));
$a[&apos;b&apos;]=&apos;new&apos;;
var_dump($a);
</code></pre><blockquote>
<p>都知道两面镜子对着放时，镜子里的镜像吧，如果这两个镜子里面有一样的数组呢？</p>
</blockquote>
<pre><code>&lt;?php
$a=[123,&apos;abc&apos;];
$a[]=&amp;$a;
print_r($a);
//Array
// ( [0] =&gt; 123
// [1] =&gt; abc 
//[2] =&gt; Array (
    // [0] =&gt; 123 
    //[1] =&gt; abc 
    //[2] =&gt; Array *RECURSION* ) )这个意思是数组递归，这很蛋疼啊，        
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/17/字符串函数/" itemprop="url">
                  php字符串函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-17T11:15:00+08:00" content="2016-03-17">
              2016-03-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/17/字符串函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/17/字符串函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>###1.字符串函数</p>
<p>###2.正则表达是函数</p>
<p>###3.perl兼容正则表达式函数</p>
<p>###4.url字符串函数</p>
<p>###5.加解密函数</p>
<p>###6.字符类型函数</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/数据类型/" itemprop="url">
                  php类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T15:58:34+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/12/数据类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/12/数据类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###1.标量类型</p>
<blockquote>
<p>###1.布尔型boolean</p>
</blockquote>
<p>#####关键字TURE FALSE</p>
<blockquote>
<p>以下数值在判断时会被转换为FALSE：FALSE,0,0.0,””,”0”,    [],NULL,不包含成员变量的对象(空object),空标记(类似：<code>&lt;a&gt;&lt;/a&gt;</code>)生成的SimpleXML对象</p>
</blockquote>
<p>#####例子：<br>    &lt;?php<br>        $x=TRUE;<br>        $y=FALSE;<br>        $z=$x &amp;&amp; $y;<br>        //此时$z 为false 因为&amp;&amp;优先级大于 = 所以先计算 $x和$y的与运算，其中一个为False 结果为false  ,然后false赋值给$z<br>        $z=$x and $y;<br>        //此时$z=true,因为 = 的优先级大于 and 所以 执行顺序是 $x值给$z ，而之后和$y的and值无人接收 ，可以看下面的代码<br>        $res=($z=$x and $y);<br>        //此时$res=false,同理下面一段代码：</p>
<blockquote>
<p>我要把尼萌割开</p>
</blockquote>
<pre><code>&lt;?php 
$x=TRUE;
$y=FALSE;
$z=$x &amp;&amp; $y; //$z=false 
$z1=$x and $y;//$z1=true
$z2=$y &amp;&amp; $x;//$z2=false
$z3=$y and $x;//$z3=false
$a=$x or $y;//$a=true
$a1=$x || $y;//$a1=true
$a2=$y or $x;//$a2=false
$a3=$y || $x;//$a3=true
</code></pre><hr>
<blockquote>
<p>###2.整形int</p>
</blockquote>
<p>整形可以是十，十六，八，二进制的数，可以在前面加上+ 或 -<br>整形的值如果超出了整形的长度范围（32位系统和64系统位长度不同），会自动转换为float。</p>
<pre><code>&lt;?php 
    $a=25/7;
    var_dump($a);//float 3.57142857143
    var_dump((int)$a);//3,强转舍弃小数
    var_dump(intval($a));//3，强转舍弃小数 Intval函数可加第二个参数，来制定转换的进制
    var_dump(round($a));//4，//round 为四舍五入，3.57....四舍五入向上取整
</code></pre><p>其他类型转换为整形：<br>    从boolean转化为整形时，false-&gt;0, true-&gt;1<br>    从string转换为整形时，如果字符串以合法的数值开始则使用该数值，否则转换的值为0<br>    从浮点类型转化为整形时，向下取整，Php浮点数精度有限，在数学运算中会带来很大误差，官网中有一段代码：</p>
<pre><code>&lt;?php
    $a=0.1;
    $b=0.7;
    echo intval(($a+$b)*10);
    //结果是7 而不是想象中的8，官网上说计算的结果在内部表示为7.9999999999999991118...
    //我也不懂为什么，因为如果把$b换成0.8的话，就能得出正确结果9
    //php提供了更高精度的数学函数：BC数学函数和gmp函数
    //总而言之浮点数不要直接比较或者运算，
    //还有一段
&lt;?php 
    $num=19.99;
    var_dump(gettype($num));//获取类型double
    var_dump($num*100);//浮点数乘100 为float1999
    var_dump(intval($num*100));//浮点数1999获取整数数值，为1998,丢失精度
    var_dump(intval(strval($num)*100));//首先strval得到string &apos;19.99&apos; 
    //再和100相乘的时候，自动转换为float19.99在乘100后得到与上面一样的结果
    var_dump(intval(strval($num*100)));//结果为int 1999 .首先浮点数乘100得到float 1999 ，
    //然后转化为string &apos;1999&apos;,在之后获取string &apos;1999&apos;的整数值的时候没有丢失精度？得到结果为int 1999
</code></pre><p>一段使用Int的方式存储ip和取出ip的方法</p>
<pre><code>&lt;?php 
$ipArr = explode(&apos;.&apos;,&apos;12.12.34.23&apos;);
$ip = $ipArr[0]*0x1000000//16进制数转化为10进制 （intval(0x1000000,10)）为256的立方
    +$ipArr[1]*0x10000//256的平方
    +$ipArr[2]*0x100//256
    +$ipArr[3];
    //也可以用这种简单的写法
    //$ip = ($ipArr[0]&lt;&lt;24)
    //+($ipArr[1]&lt;&lt;16)
    //+($ipArr[2]&lt;&lt;8)
    //+$ipArr[3];
//    echo $ip.&quot;&lt;/br&gt;&quot;;
echo $ip.&quot;&lt;/br&gt;&quot;;

$ipVal = $ip;
$ipArr = array(0 =&gt;floor($ipVal/0x1000000) );
$ipVint   = $ipVal-($ipArr[0]*0x1000000); // for clarity
$ipArr[1] = ($ipVint &amp; 0xFF0000)  &gt;&gt; 16;
$ipArr[2] = ($ipVint &amp; 0xFF00  )  &gt;&gt; 8;
$ipArr[3] =  $ipVint &amp; 0xFF;
$ipDotted = implode(&apos;.&apos;, $ipArr);
echo $ipDotted;
</code></pre><hr>
<blockquote>
<p>###3.浮点型</p>
</blockquote>
<p>#####浮点数在php中叫float 也叫 double 也可以叫 real ，这一点很蛋疼，但是他们三个确实是没有区别的，比如：</p>
<pre><code>&lt;?php
    $a=1.1;
    printf(gettype($a));
    var_dump($a);
    //结果是：
    //double
    //float(1.1)
    //so,choose the one you like 
</code></pre><p>#####浮点数的长度和凭他相关，通常最大值是 1.8e308 并具有 14 位十进制数字的精度</p>
<p>#####因为浮点数的精度问题，在比较浮点数的时候，会使用一个迂回的方法，就是比较一个极小误差值<br>    &lt;?php<br>        $a=0.17;<br>        $b=1-0.83;<br>        var_dump($a==$b);<br>        var_dump(abs($a-$b)&lt;0.00001);<br>        //第一个vardump为 false 而第二个为true</p>
<p>#####在确定了想要的小数位之后也可以使用round函数来帮助判断：<br>    &lt;?php<br>    $a=0.17;<br>    $b=1-0.83;<br>    var_dump(round($a,2)==round($b,2));//结果是true,round函数会把第一个参数按照四舍五入，并保留第二个参数长度的小数位数</p>
<p>#####和Js一样当出现无法正常计算的时候会产生一个NaN的结果，NaN代表着任何不同的值，和任何值包括自身比较都不相等，判断NaN的时候使用  is_nan()函数 </p>
<hr>
<blockquote>
<p>###4.字符串string</p>
</blockquote>
<p>#####手册上说一个字符串是由一系列字符组成，其中每一个字符等于一个字节，并且Php只能支持256的字符集，因此不支持Unicode,关于字符集,我看了阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">ASCII UTF-8 Unicode 之间的联系和区别</a>，但还是没有理解手册的意思，然后看了一位<a href="http://www.cnblogs.com/chenpingzhao/p/4811990.html" target="_blank" rel="external">博主的文章</a>,大概对所谓的不支持Unicode有了写了解，简单说就是一些字符串的函数都有一个针对Unicode的加了前缀的函数，比如： mb_substr()，还有一些输出函数需要提供字符集名字的参数。</p>
<blockquote>
<p>而另一方面的资料普遍是这样说的：</p>
</blockquote>
<pre><code>这只是说，PHP的string类型是array of bytes。
PHP是可以正常使用Unicode的。我的经验是：
PHP脚本文件本身使用UTF-8字符集。
网页使用utf-8编码。
MySQL数据库使用utf8字符集。
各类字符串操作使用Multibyte String系列函数。
</code></pre><blockquote>
<p>我比较相信的一个结论是：</p>
</blockquote>
<p>  <strong>unicode作为字符串 保存起来的只是它的编码 php不解析他就不会出问题</strong></p>
<blockquote>
<p>字符串表现形式一：单引号</p>
</blockquote>
<p>#####单引号包围的字符串中的变量和转义不会被替换,当然想要在单引号中标示单引号需要用<code>\</code>来转义</p>
<pre><code>&lt;?php
    echo &apos;o www  w&apos;.&quot;&lt;br \&gt;&quot;;//o www w
    echo &apos;123
    4
    5
    67&apos;.&quot;&lt;br \&gt;&quot;;//123 4 5 67
    echo  &apos;are you &quot;ok\&apos;&quot;&apos;.&quot;&lt;br \&gt;&quot;;//are you &quot;ok&apos;&quot; (ok后面有一个单引号和一个双引号，如果不加\转义会报语法错误)
    echo &apos;cd C:\*.*?&apos;.&quot;&lt;br \&gt;&quot;;//cd C:\*.*?
    echo &apos;cd C:\\*.*?&apos;.&quot;&lt;br \&gt;&quot;;//cd C:\*.*?
    echo &apos;you are \n ok&apos;.&quot;&lt;br \&gt;&quot;;//you are \n ok
    echo &apos;echo $a&apos;.&quot;&lt;br \&gt;&quot;;//echo $a
</code></pre><blockquote>
<p>字符串表现形式之二：双引号</p>
</blockquote>
<p>#####双引号中可以解析变量，也是有一些转义字符，举一些常用的例子：</p>
<pre><code>&lt;?php
header(&apos;Content-type: text/plain&apos;);//text/plain告诉浏览器是纯文本格式，\n \r等转义字    //符才可以生效否则不生效
echo &quot;the n \n&quot;;//换行
echo &quot;the r \r&quot;;//换行
echo &quot;the dollar \$ \n&quot;;//输出$
echo &quot;the \\ \n&quot;;//输出\
echo &quot;the \&quot;\n&quot;;//输出&quot;
$a=&apos;World&apos;;
$arr=[&apos;Hello&apos;,&apos;World&apos;];
echo &quot;Hello $a\n&quot;;//输出 Hello World双引号中可以解析变量中的字符串
echo &quot;$arr[0] $arr[1]\n&quot;;//输出Hello World 双引号可以解析数组中的value
    class obj{
        public $a=&quot;Hello&quot;;
        public $b=&quot;World&quot;;
    }
$obj=new obj;
echo &quot;$obj-&gt;a $obj-&gt;b&quot;;//输出HelloWorld 双引号中可以解析对象的属性
</code></pre><blockquote>
<p>字符串表现形式之三:Heredoc</p>
</blockquote>
<p>#####语法：<code>&lt;&lt;&lt;</code>加上一个自定义的标识符，标识符由字符数字下划线组成，字母下划线开头，结束时单独一行以标识符作为结束标志，并且结束标志之前不得有任何东西，这种形式的字符串也可以解析变量和转义序列，详见下面的例子：</p>
<pre><code>&lt;?php
header(&apos;Content-type: text/plain&apos;);
cLass right {
    protected $foo=&apos;class.var&apos;;
    protected $fooArr=[&apos;class.arr&apos;];
    }
class child_right extends right {
    function a(){
         $h=&quot;Hello&quot;;
         $r=new right();
        $str=&lt;&lt;&lt;abc
        $h,World 
        the &quot;&quot;
        the &apos;&apos;
        the \
        the \\
        $this-&gt;foo
        $r-&gt;foo
        {$this-&gt;fooArr[0]}
        {$r-&gt;fooArr[0]}
        parent::foo
        self::foo
abc;
    echo $str;
    }
}
$a=new child_right();
$a-&gt;a();
//结果是这样的
// Hello,World 
//     the &quot;&quot;
//     the &apos;&apos;
//     the \
//     the \
//     class.var
//     class.var
//     class.arr
//     class.arr
//     parent::foo
//     self::foo
</code></pre><p>#####Heredoc也可以和正常的<code>&quot;&quot;</code> <code>&#39;&#39;</code>一样作为参数传给函数：<br>    &lt;?php<br>    class one{<br>        function __construct($h,$w){<br>            echo $h.$w;<br>        }<br>    }<br>    class two{<br>        function arr($arr){<br>            echo $arr[0].$arr[1];<br>        }<br>    }<br>    $a =new one(&lt;&lt;<val1 hello,="" val1="" ,<<<val2="" world="" val2="" );="" $b="new" two();="" $b-="">arr([<br>    &lt;&lt;&lt;val1<br>    Hello,<br>    val1<br>    ,&lt;&lt;&lt;val2<br>    World<br>    val2<br>        ]);<br>    //上面的代码会输出两遍Hello,World</val1></p>
<p>#####Heredoc也可以用来初始化变量,但需要注意的是不能在初始化变量的时候在字符串内加入变量！！<br>    &lt;?php<br>    class demo{<br>        public $str=&lt;&lt;<abc str.text="" abc;="" const="" cstr="<<<EFG" cstr.text="" efg;="" static="" $sstr="<<<HIJ" sstr.text="" hij;="" function="" getsstr(){="" echo="" self::$sstr;="" }="" $d="new" demo();="" $d-="">str.”<br>“;//类的属性<br>    echo demo::cstr.”<br>“;//类的常量<br>    echo demo::$sstr.”<br>“;//类的静态属性<br>    echo demo::getSstr();//类的静态方法<br>    //好吧在开头位置也可以用双引号吧他标识符包起来，虽然我不知道这有什么用也许是为了方便联想<br>    echo $test=&lt;&lt;&lt;”aa”<br>    123<br>    aa;</abc></p>
<blockquote>
<p>字符串表现形式之四：Newdoc</p>
</blockquote>
<p>#####如果说Heredoc类似于<code>&quot;&quot;</code>那么Newdoc就是类似于<code>&#39;&#39;</code>的，在语法上Newdoc和Heredoc一样需要开始和结束标识符，唯一的不同是Newdoc的开始标识符需要加上单引号：<code>&lt;&lt;&lt;&#39;ABC&#39;</code>,并且它和<code>&#39;&#39;</code>相同的地方还有同样对变量不解析和不会对特殊字符转义:<br>    &lt;?php<br>    $a=1;<br>    class c<br>    {<br>        //Newdoc可以用在各种属性和常量上这和Heredoc不同，毕竟Newdoc不解析变量<br>        public $newdoc=&lt;&lt;&lt;’NEW’<br>        the newdoc text<br>    NEW;<br>        function b()<br>        {<br>            echo ‘b-&gt;b’;<br>        }<br>        function a(){<br>            echo ‘b-&gt;a’;<br>        }<br>    }<br>    $b=new c();<br>    echo &lt;&lt;&lt;’DE’<br>    the \<br>    the $a<br>    the $b-&gt;b();<br>    the C:\<br>    the {$b-&gt;a}<br>    the ‘’<br>    the “”<br>    the \n<br>    DE;<br>    // 输出：<br>    //     the \<br>    //     the $a<br>    //     the $b-&gt;b();<br>    //     the C:\<br>    //     the {$b-&gt;a}<br>    //     the ‘’<br>    //     the “”<br>    //     the \n<br>         ?&gt;</p>
<blockquote>
<p>变量解析</p>
</blockquote>
<pre><code>&lt;?php
$arr=[
    &apos;foo&apos;=&gt;[&apos;foo1&apos;,&apos;foo2&apos;],
    [&apos;1=&gt;2&apos;]
];
$str=&apos;str&apos;;
echo &quot;{$arr[&apos;foo&apos;][0]}&quot;;//foo1,当要用到带引号的key的时候必须用{}
echo &quot;{$arr[&apos;foo&apos;][1]}&quot;;//foo2
echo &quot;{$arr[0][0]}&quot;;//1=&gt;2
echo &quot;{$str}&quot;//str
echo &quot;${str}&quot;;//str
// echo &quot;${arr[&apos;foo&apos;][0]}&quot;;
//这条会报语法错误，与上一条不同，数组不可以用${}这种写法
</code></pre><p>调用类的属性</p>
<pre><code>    &lt;?php
    class foo {
        public $bar = &apos;I am bar.&apos;;
    }

    $foo = new foo();
    $bar = &apos;bar&apos;;
    $baz = array(&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;quux&apos;);
    echo &quot;{$foo-&gt;$bar}&quot;.&quot;&lt;/br&gt;&quot;;
    echo &quot;{$foo-&gt;bar}&quot;.&quot;&lt;/br&gt;&quot;;//bar前面写不写这个$感觉是没有区别的
    echo &quot;{$foo-&gt;$baz[1]}&quot;.&quot;&lt;/br&gt;&quot;;//这个就是先把数组$baz[1]也就是bar表达出来了，就是变成了$foo-&gt;bar了，不是说去找foo的baz属性
    echo &quot;{\$&quot;;
    //输出一下内容
//I am bar.
//I am bar.
//I am bar.
//{$
    ?&gt;
</code></pre><p>常量，类的静态变量和类属性的对比</p>
<pre><code>&lt;?php
class resolve{
    const convar=&apos;convar&apos;;
    public $classarg=&apos;classarg&apos;;
    public static  $staticarg=&apos;staticarg&apos;;
}
$r=new resolve();
echo resolve::convar;//输出convar
echo &quot;{${resolve::convar}}&quot;;//这一行会报Notice变量$convar未定义，因为在{}中无法处理类常量
$convar=123;
echo &quot;{${resolve::convar}}&quot;;//输出123，声明了 $convar之后,程序可以正常执行，但是只能使用类常量的值来作为变量名字来解析
echo &quot;$r-&gt;classarg&quot;;//输出classarg
echo &quot;{$r-&gt;classarg}&quot;;//输出classarg
echo resolve::$staticarg;//输出staticarg
echo &quot;${resolve::$staticarg}&quot;;//这里和上面那个Notice是一样的
echo $staticarg=&apos;staticarg&apos;;
echo &quot;{${resolve::$staticarg}}&quot;;//输出staticarg 声明了上面那个变量之后，以常量的值来作为变量的名字然后被字符串解析
?&gt;
</code></pre><p>存取和修改字符串中的字符,php内部使用字节组成数组来表示字符串，所以可以用Key的方式来访问和修改字符串中的字符，但字符串Key必须为整数（5.4之后）</p>
<pre><code>&lt;?php 
$a=&apos;abcdefghijklmn&apos;;
var_dump(strlen($a));//14
var_dump($a{0});//a
var_dump($a[13]);//n
var_dump($a[strlen($a)-1]);//n
var_dump($a{strlen($a)-1});//n
$a=&apos;123456&apos;;
var_dump($a{0});//1
var_dump($a[1]);//2
$a=&quot;我是汉子&quot;;
var_dump($a{0});//乱码 这种访问字节的方式只能在单字节是使用比如子母和数组，而其他字符一般有2-4个字节
var_dump($a[1]);//乱码
$str=&apos;abc&apos;;
var_dump($str[&apos;1&apos;]);//b
var_dump(isset($str[&apos;1&apos;]));//true

var_dump($str[&apos;1.0&apos;]);//b,把1.0转成1了所以输出b
var_dump(isset($str[&apos;1.0&apos;]));//false，但是没有没有Key=1.0(浮点数)这种Key

var_dump($str[&apos;u&apos;]);//u转成0,此处报非法字符串偏移量的waring
var_dump(isset($str[&apos;u&apos;]));//false 没有u这个key

var_dump($str[&apos;1df&apos;]);//b 也许是因为前面有个1就转成1，此处报了数据结构不对的notice
var_dump(isset($str[&apos;1df&apos;]));//false

var_dump($str[&apos;2df&apos;]);//c ,也许是因为前面有2就转成2，此处报了和上面一样的notice
var_dump(isset($str[&apos;2df&apos;]));
</code></pre><p>转换为字符串类型</p>
<pre><code>&lt;?php
//标量类型可以用(string)或者strval()来转为字符串
//当需要一个字符串的时候php会自动转换 比如echo print 
class obj{}
$obj=new obj();
$int=123;
$float=1.22;
$arr=[&apos;123&apos;,123,&apos;abc&apos;];
$true=true;
$false=false;
$resouce=dir(getcwd());//dir函数以oop的形式返回路径和文件资源
var_dump($resouce);
var_dump($int+&apos;123&apos;); //int 246
var_dump($float+&apos;123&apos;);//float 124.22
// var_dump($arr+&apos;123&apos;);//这里会报fatal error
var_dump($true+&apos;123&apos;);//int 124
var_dump($false+&apos;123&apos;);//int 123
var_dump(strval($float));//string &apos;1.22&apos;
var_dump(strval($true));//string &apos;1&apos;
var_dump(strval($false));//string &apos;&apos;(length=0)
var_dump((string)$false);//string &apos;&apos;(length=0)
var_dump(strval($arr));//结果是string &apos;Array&apos;,并报一个Notice
var_dump(strval($int));//strint&apos;123&apos;
// var_dump(strval($obj));//致命错误
var_dump(strval($resouce-&gt;handle));//string &apos;Resource id #3&apos; 资源类型转为str会返回一个这种字符串其中`#`后面的数字为Php为该资源分配的id
//，这种方法不可靠，需要知道资源类型的时候，参考get_resouce_type 方法
var_dump(strval(null));//string &apos;&apos; (length=0)
//官网说array object resouce这三种类型只会得到对应的type name，
</code></pre><p>大部分的php值可以转变为string 来永久保存，这被称作串行化，（序列化）：</p>
<pre><code>&lt;?php
$a=&apos;123&apos;;
var_dump($sa=serialize($a));//string &apos;s:3:&quot;123&quot;;&apos; 序列化
var_dump(unserialize($sa));//string &apos;123&apos; 反序列化
</code></pre><p>字符串转换为数值</p>
<pre><code>&lt;?php
//字符串中没有`.` `e`,`E`,并且长度在整形的范围之内，该字符串被当做interger来取值，否则是float
//并且字符串的开始字符如果不是合法的数值则转为0，正负号跟着数字视为合法的数值
var_dump(1+&apos;10.1&apos;);//float 11.1
var_dump(1+&apos;-1.4e3&apos;);//float 1399
var_dump(1+&apos;asb123&apos;);//int 1
var_dump(1+&apos;123asb&apos;);//int 124
var_dump(1+&apos;123.1asb&apos;);//float 124.1
var_dump(1.0+&apos;123asb&apos;);//folat 124
</code></pre><p>字符类型详解<br>内容挺多的，没详细学习。手册是这么说的：</p>
<blockquote>
<p>某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如 substr()，strpos()，strlen() 和 strcmp()。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。<br>某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如 htmlentities() 和 mbstring 扩展中的大部分函数。<br>其它函数使用了当前区域（见 setlocale()），但是逐字节操作。例如 strcasecmp()，strtoupper() 和 ucfirst()。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如 strtoupper(“á”) 在区域设定正确并且 á 是单字节编码时会返回 “Á”。如果是用 UTF-8 编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。<br>最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。intl 扩展和 PCRE（上例中仅在使用了 u 修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，utf8_decode() 会假定 UTF-8 编码而 utf8_encode() 会假定 ISO-8859-1 编码。</p>
</blockquote>
<pre><code>&lt;?php
$a=&apos;阿布&apos;;
echo substr($a, 1).&quot;&lt;/br&gt;&quot;;//��布
echo mb_substr($a, 1).&quot;&lt;/br&gt;&quot;;//布
//以上是因为substr默认是单字节，而中文一定不是单字节，mb_substr是做多字节处理的，也接受编码类型的参数，默认是内部字符编码

$b=&apos;ab&apos;;
echo substr($b, 1).&quot;&lt;/br&gt;&quot;;//b
//内容太多不写demo了
</code></pre><blockquote>
<p>demo</p>
</blockquote>
<pre><code>&lt;?php
//日期格式的字符串比较
$a=&apos;2015-12-1&apos;;
$b=&apos;2015-12-2&apos;;
var_dump(strtotime($a)&gt;strtotime($b));//false
var_dump($a==$b);//false
var_dump ($a&gt;$b);//false $a&lt;$b
$c=&apos;2015-12-1 12:12:12&apos;;
$d=&apos;2015-12-1 12:12:13&apos;;
var_dump(strtotime($c)&gt;strtotime($d));//false
var_dump($c==$d);//false
var_dump($c&gt;$d);//false $c&lt;$d
</code></pre><p>&gt;</p>
<pre><code>&lt;?php
define(&apos;DEMO&apos;,&apos;123&apos;);
const ABC=1;
echo ABC;
$getdefine=get_defined_constants();
//其实想说的还是字符串里最好还是解析变量尽量不要写别的结构
echo &lt;&lt;&lt;DEMO
get_defined_constants(&apos;DEMO&apos;)
{get_define_constants(&apos;DEMO&apos;)}
{$getdefine[&apos;DEMO&apos;]}
{ABC}
DEMO;
//输出get_defined_constants(&apos;DEMO&apos;)
//{get_define_constants(&apos;DEMO&apos;)}
//123
//{ABC}
</code></pre><p>&gt;</p>
<pre><code>&lt;?php
//在花括号中写各种表达式的语法
function funcName($a){
    return $a;
}
$funcName=&apos;funcName&apos;;
function funcName2($c,$d){
    return $c*$d;
}
$funcName2=&apos;funcName2&apos;;
echo &quot;{funcName(1)}&quot;;//{funcName(1)}
echo &quot;{$funcName(&apos;succ&apos;)}&quot;;//succ
echo &quot;{$funcName2(2,5)}&quot;;//10
//其实这就是一种把语法技巧，把方法名用字符串来标示
</code></pre><p>&gt;</p>
<pre><code>&lt;?php
class Test {
    const ONE = &apos;a&apos;;
    const TWO= &apos;b&apos;;
}
echo &quot;foo {Test::ONE} bar {Test::TWO}&quot;;//输出：foo {Test::ONE} bar {Test::TWO}f
//以上是官网的例子 就是说不能直接用静态变量
//这个是我写的 想用在字符串中利用静态变量做为变量名，也许在开发中会用到，但是我觉得这是脱裤子放屁
$a=1;
$b=2;
echo &quot;foo ${Test::ONE} bar ${Test::TWO}&quot; ;
?&gt;
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/07/语法/" itemprop="url">
                  php语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-07T14:57:52+08:00" content="2016-03-07">
              2016-03-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/07/语法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/07/语法/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-php标记"><a href="#1-php标记" class="headerlink" title="1.   php标记"></a>1.   php标记</h3><blockquote>
<p>纯php代码的文件不要写结束标记<code>?&gt;</code>，可以避免输出结束标记后面无意义的换行或空格或什么奇怪的东西</p>
</blockquote>
<h3 id="2-php开始和闭合标签在页面中会对换行造成影响"><a href="#2-php开始和闭合标签在页面中会对换行造成影响" class="headerlink" title="2.    php开始和闭合标签在页面中会对换行造成影响"></a>2.    php开始和闭合标签在页面中会对换行造成影响</h3><blockquote>
<p>一段简单的代码：</p>
</blockquote>
<pre><code>我来组成头部
&lt;pre&gt;
I
&lt;?php echo &quot;am&quot;;?&gt;
good
&lt;/pre&gt;
</code></pre><blockquote>
<p>会显示如下效果：</p>
</blockquote>
<pre>
我来组成头部
    I
    am    Good
    </pre>

<blockquote>
<p>而如果我这么写,在<code>?&gt;</code>后面加上<code>.</code>或者一个空格:</p>
</blockquote>
<pre><code>&lt;pre&gt;
我来组成头部
I
&lt;?php echo &quot;am&quot;;?&gt;.
good
&lt;/pre&gt;
</code></pre><blockquote>
<p>结果就是这样</p>
</blockquote>
<pre>
我来组成头部
    I
    am.
    Good
</pre>

<p>#####原因就是因为<code>?&gt;</code>把该行结束的换行删掉了，重新加一个字符或者空格就可以重新保持该行末尾的换行了。</p>
<h3 id="3-标记格式"><a href="#3-标记格式" class="headerlink" title="3.    标记格式"></a>3.    标记格式</h3><blockquote>
<p>PHP的开始结束标记支持四种格式</p>
</blockquote>
<pre><code>1.   &lt;?php echo 123; ?&gt;
2.   &lt;script language=&quot;php&quot;&gt;
        echo 123;
     &lt;/script&gt;
3.   &lt;? echo 123; ?&gt;
     &lt;?= 123 ?&gt;
4.   &lt;% echo 123; %&gt;
</code></pre><p>#####其中 1和2 总是可用的， 但谁会没事多打代码呢 ，所以大家都用1</p>
<p>#####而3为短标记，不建议使用，他不利于代码移植，启用短标记需要在 <code>php.ini</code> 配置文件中打开指令 <code>short_open_tag</code> 才可使用。而其中 <code>&lt;?= 123 ?&gt;</code>这种输出格式在php5.4之后无需打开<code>short_open_tag</code>，也可使用。</p>
<p>#####而4这种asp风格的东西，我是拒绝的，启用它也要改<code>php.ini</code>文件。</p>
<h3 id="4-从html中分离"><a href="#4-从html中分离" class="headerlink" title="4.    从html中分离"></a>4.    从html中分离</h3><blockquote>
<p>在我不长的开发时间里，这种东西一般都是让模板引擎来干，或者就不要模板引擎了</p>
</blockquote>
<p>比如,这种判断的使用：</p>
<pre><code>&lt;?php $a=1;?&gt;
&lt;?php if($a==1): ?&gt;
a=1
&lt;?php else: ?&gt;
a!=1
&lt;?php endif; ?&gt;
</code></pre><blockquote>
<p>当然，页面中会输出 a=1</p>
</blockquote>
<p>也可以使用在Html标签内，style中或者写在css中：</p>
<pre><code>//写在html标签内,div中会显示red：
&lt;?php $color=&apos;red&apos; ?&gt;
&lt;div id=&quot;test_div&quot;
     &lt;?php if($color==&apos;red&apos;): ?&gt; 
     class=&quot;red&quot;
     &lt;?php else: ?&gt;
     class=&quot;green&quot; 
     &lt;? endif; ?&gt;
     &gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var divs= document.getElementById(&apos;test_div&apos;);
        var className=divs.className;
         divs.innerHTML=className;
    &lt;/script&gt;
&lt;/div&gt;
//写在style中,下面的会显示一个100*100的红色div：
&lt;?php $color=&apos;red&apos; ?&gt;
    &lt;div id=&quot;test_div&quot;  style=&quot;width:100px;height:100px;background-color:&lt;?php     if     ($color==&apos;red&apos;): ?&gt; red &lt;? else: ?&gt; green &lt;?php endif; ?&gt;;&quot;&gt;
    &lt;/div&gt;
//写在style标签中，会显示一个100*100的红色div
&lt;html&gt;
    &lt;head&gt;
        &lt;?php $color=&apos;red&apos;; ?&gt;
        &lt;style type=&quot;text/css&quot;&gt;
        #test{
            width:100px;
            height:100px;
            &lt;?php if($color==&apos;red&apos;): ?&gt;
            background-color:red;
            &lt;?php else: ?&gt;
            background-color: green;
            &lt;?php endif; ?&gt;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote>
<p>循环输出下面这个数组：</p>
</blockquote>
<table><thead><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></thead><tr><td>零</td><td>一</td><td>二</td><td>三</td><td>四</td><td>五</td><td>六</td><td>七</td><td>八</td><td>九</td></tr><tr><td>男</td><td>女</td><td>男</td><td>女</td><td>男</td><td>女</td><td>男</td><td>女</td><td>男</td><td>女</td></tr></table>

<pre><code>//循环输出上面的数组代码：
&lt;?php 
    $id=[0,1,2,3,4,5,6,7,8,9];
    $data=[
        [&apos;name&apos;=&gt;&apos;零&apos;,&apos;sex&apos;=&gt;&apos;男&apos;],
        [&apos;name&apos;=&gt;&apos;一&apos;,&apos;sex&apos;=&gt;&apos;女&apos;],
        [&apos;name&apos;=&gt;&apos;二&apos;,&apos;sex&apos;=&gt;&apos;男&apos;],
        [&apos;name&apos;=&gt;&apos;三&apos;,&apos;sex&apos;=&gt;&apos;女&apos;],
        [&apos;name&apos;=&gt;&apos;四&apos;,&apos;sex&apos;=&gt;&apos;男&apos;],
        [&apos;name&apos;=&gt;&apos;五&apos;,&apos;sex&apos;=&gt;&apos;女&apos;],
        [&apos;name&apos;=&gt;&apos;六&apos;,&apos;sex&apos;=&gt;&apos;男&apos;],
        [&apos;name&apos;=&gt;&apos;七&apos;,&apos;sex&apos;=&gt;&apos;女&apos;],
        [&apos;name&apos;=&gt;&apos;八&apos;,&apos;sex&apos;=&gt;&apos;男&apos;],
        [&apos;name&apos;=&gt;&apos;九&apos;,&apos;sex&apos;=&gt;&apos;女&apos;],
        ];
?&gt;
&lt;style type=&quot;text/css&quot;&gt;
table,td,tr{
    border:solid #add9c0; border-width:0px 1px 1px 0px; padding-left:;
            }
&lt;/style&gt;
&lt;table &gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;?php foreach($id as $k=&gt;$val): ?&gt;
            &lt;td&gt;&lt;?php echo $val; ?&gt;&lt;/td&gt;
            &lt;?php endforeach; ?&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
        &lt;tr&gt;
            &lt;?php foreach($id as $k=&gt;$val): ?&gt;
                &lt;td&gt;&lt;?php echo $data[$val][&apos;name&apos;]?&gt;&lt;/td&gt;

            &lt;?php endforeach; ?&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
             &lt;?php foreach($id as $k=&gt;$val): ?&gt;
                &lt;td&gt;&lt;?php echo $data[$val][&apos;sex&apos;]?&gt;&lt;/td&gt;
            &lt;?php endforeach; ?&gt; 
        &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="uploads/touxiang.jpeg"
               alt="秋哥" />
          <p class="site-author-name" itemprop="name">秋哥</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">秋哥</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gbq"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
